<!DOCTYPE html>
<html lang='en'>
  <head>
    <meta charset='utf-8'>
    <title>Web Wishes</title>
    <script src='http://www.w3.org/Tools/respec/respec-w3c-common' async></script>
    <script class='remove'>
      var respecConfig = {
              specStatus:   "unofficial"
          ,   shortName:    "html-web-wishes"
          ,   editors:      [{ name: "Robin Berjon", url: "http://berjon.com/",
                               company: "W3C", companyURL: "http://w3.org/" }]
          ,   wg:           "HTML Working Group"
          ,   wgURI:        "http://www.w3.org/html/wg/"
          ,   wgPublicList: "public-web-intents"
          ,   wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/40318/status"
          ,   edDraftURI:   "http://darobin.github.com/web-wish/"
          ,   license:      "cc-by"
          ,   bugTracker: {
                  "new":  "https://github.com/darobin/web-wish/issues/new"
              ,   open:   "https://github.com/darobin/web-wish/issues"
              }
        };
    </script>
    <style>
      figcaption {
          padding-left: 50px;
          font-size:  0.8em;
          font-weight:  bold;
      }
      figcaption .fig-title {
          font-weight:  normal;
      }
      section {
          max-width:  900px;
      }
      dl dd {
          margin-bottom: 0.5em;
      }
    </style>
  </head>
  <body>
    <section id='abstract'>
      <p>
        This specification defines a mechanism for Web applications to register themselves as
        being able to handle certain specific types of services ("grant wishes") with a user
        agent. Once a service handler is registered, any Web application can then request its
        functionality from the user agent in order to compose the service into itself.
      </p>
    </section>
    <section id='sotd'>
      <p>
        This specification is a proposed extension specification to HTML and has no official
        standing whatsoever.
      </p>
    </section>
    <section>
      <h2>Introduction</h2>
      <p>
        This specification defines a mechanism for Web applications to register themselves as
        being able to handle certain specific types of services ("grant wishes") with a user
        agent. Once a service handler is registered, any Web application can then request its
        functionality from the user agent in order to compose the service into itself.
      </p>
      <p>
        For instance, a Web application could register itself as an image editor. When another
        application needs image editing functionality (e.g. a meme generator) then it can 
        instantiate the image editor as part of itself (typically in an <code>iframe</code>). The
        editor is selected based on user preference rather than by hardcoding it. This provides a
        simple yet powerful component model for Web applications.
      </p>
      <p>
        This functionality is similar to that provided in Android Intents or in FirefoxOS   
        Activities. However, in order to ship more quickly and to explore the simpler options first
        this specification is limited to a subset of the functionality afforded in existing systems.
      </p>
    </section>
    <section>
      <h2>Usage Scenarios</h2>
      <p>
        This section details a variety of usage scenarios for Wishes in order to help define how
        exactly they should work.
      </p>
      <p>
        Note that all code examples are provisional and use completely made up syntax. The scenarios
        rely on the following loose terminology (to be tightened up when the view is clearer).
      </p>
      <dl>
        <dt><dfn>application</dfn></dt>
        <dd>
          A regular Web application running in the user's browser, and typically calling upon wishes
          in the following scenarios.
        </dd>
        <dt><dfn>wish service</dfn></dt>
        <dd>
          A Web page written in such a way that it knows how to fulfil a wish and that exposes
          functionality to the application in that way.
        </dd>
      </dl>
      <section>
        <h2>Fire &amp; Forget</h2>
        <p>
          This is the simplest case. Here the <a>application</a> formulates a wish but does not care
          about any return value, or even about the success, of the wish.
        </p>
        <p>
          A typical example is the wish to share. The user is visiting an application page,
          finds it most cromulous, and wishes to share it with the world at large.
        </p>
        <figure>
          <img src='img/scenarios/share-click.jpg' width="800" height="497">
          <figcaption>
            User clicks the “share” button in order to share this most cromulous piece of humour.
          </figcaption>
        </figure>
        <p>
          Creating a share button is a simple matter of attaching a handler to it and formulating
          a wish.
        </p>
        <pre class='example highlight'>
          &lt;button id='share'>&#128571; Share this!&lt;/button>
          &lt;!-- … -->
          &lt;script>
            document.querySelector("#share").onclick = function () {
                new Wish("share", "text/plain", location.href).make();
            };
          &lt;/script>
        </pre>
        <p>
          The user is then presented with a list of wish services that she has installed in her user
          agent (or, possibly, more generally on her operating system). Of these she selects the
          “Unicorner” social sharing site where she can share with her fellow unicorns.
        </p>
        <figure>
          <img src='img/scenarios/share-picker.jpg' width="800" height="497">
          <figcaption>
            User selects “Unicorner” in the list of services that can fulfil the wish to share.
          </figcaption>
        </figure>
        <p>
          The <a>wish service</a> picker requires no work from the developer and is entirely
          handled by the user agent. The list matches wish services that the user agent knows can
          fulfil this wish (this can comprise those installed by the user, but can also come from
          other sources such as system application, a specialised search engine, etc.). Installing
          a wish into a user agent is covered in a later section.
        </p>
        <p>
          The “Unicorner” web site, which is a social sharing web site that the user happens to like
          (here showing how Wishes can help open up the Web to new contenders without having to 
          battle the inertia of millions of authors having to add new buttons to their pages), opens
          up atop the <a>application</a> being shared (with some sort of signal that the <a>wish
          service</a> is related to the <a>application</a> — all of this is naturally 
          implementation-dependent). The user can interact with it and hit “Share”.
        </p>
        <figure>
          <img src='img/scenarios/share-unicorner.jpg' width="800" height="497">
          <figcaption>
            Unicorner's next generation sharing UX.
          </figcaption>
        </figure>
        <p>
          There are two essential parts to the <a>wish service</a>'s handling of the wish. The first
          part is being notified of the wish, including of the wish's payload and acting 
          accordingly in order to fulfil it. The code for this is straightforward.
        </p>
        <pre class='example highlight'>
          &lt;textarea id='content'>&lt;/textarea>
          &lt;button id='unishare'>Share!&lt;/button>
          &lt;!-- … -->
          &lt;script>
            window.onload = function () {
                if (currentWish)
                    document.querySelector("#content").value = currentWish.data;
            };
            document.querySelector("#unishare").onclick = function () {
                // …code to actually post the message to the site…
                if (currentWish) currentWish.fulfil();
            };
          &lt;/script>
        </pre>
        <p>
          Note that the code above still needs to call <code>fulfil()</code> on the wish once the
          action is completed, even though it is returning no data to the <a>application</a>. This
          tells the user agent that the wish is fulfilled and it can use that notification for
          instance to close the tab containing the <a>wish service</a>.
        </p>
      </section>
      <section>
        <h2>Return Value</h2>
        <p>
          While “fire &amp; forget” wishes definitely have their uses, it is common for
          applications to expect data to be returned from the interaction with a
          <a>wish service</a>.
        </p>
        <p>
          In this scenario we consider the following workflow: a user wishes to create a hilarious
          meme, and goes to a meme publishing web site for that purpose. The meme publishing
          web site first asks the user to pick an image to serve as the starting point for the meme.
          That operation relies on <code>&lt;input type=file></code> in order to show how wishes
          can integrate with that part of the platform. Then it will offer to edit the image, using
          a wish to edit.
        </p>
        <p>
          In both cases, data is returned from the <a>wish service</a>, and in the second case data
          is also received by it.
        </p>
        <p>
          The application's UI is simple:
        </p>
        <figure>
          <img src='img/scenarios/memecat.png' width="397" height="374" style='border: 1px solid #aaa'>
          <figcaption>
            MemeCat — The World's Laziest Meme Maker
          </figcaption>
        </figure>
        <p>
          Clicking the first “Pick a picture” step hits an <code>&lt;input type=file></code>
          control, which in fact just formulates the wish to pick a file. To give a better idea for
          how this works, here is how you would get a list of files from a file input type.
        </p>
        <pre class='example highlight'>
          &lt;input type="file" accept="image/*" multiple id="uploads">
          &lt;script>
            document.querySelector("#uploads").onchange = function (ev) {
                handleFiles(Array.prototype.slice.call(ev.target.files));
            };
          &lt;/script>
        </pre>
        <p>
          And here is the equivalent code using a wish:
        </p>
        <pre class='example highlight'>
          &lt;button id="uploads">Upload&lt;/button>
          &lt;script>
            document.querySelector("#uploads").onclick = function () {
                new Wish("pick", "image/*", { multiple: true }).then(handleFiles);
            };
          &lt;/script>
        </pre>
        <p>
          These come out at the same amount of code. With the wish we need to handle clicking 
          ourselves which the file input type provides free, but if you ever wish to style your
          file input control then that's a plus because you will need this sort of indirection
          anyway. A positive side effect of the wish side is that you don't need no stinking
          <code>FileList</code>.
        </p>
        <p>
          It is important that the file input type and the wish to pick produce the same user
          experience since to the user, who neither knows nor cares for the page source, they are
          the same operation.
        </p>
        <p class='note'>
          For the code examples we use the <code>multiple</code> attribute in order to 
          demonstrate its mapping, but the MemeCat <a>application</a> naturally only wants a single
          image.
        </p>
        <p>
          Irrespective of how MemeCat chose to implement its file picking, the user would be
          presented with the familiar <a>wish service</a> picker:
        </p>
        <figure>
          <img src='img/scenarios/memecat-picker.png' width="397" height="374">
          <figcaption>
            The system file picker, as depicted if you let a standards geek create icons.
          </figcaption>
        </figure>
        <p>
          A <a>wish service</a> that knows how to fulfil a pick (of any kind) will return either
          a <code>File</code> or an array thereof depending on the value of the 
          <code>multiple</code> field. Such a service could be implemented using code of the kind
          that follows:
        </p>
        <pre class='example highlight'>
          &lt;div id="pics">
            &lt;-- a list of images that can be clicked to select them -->
          &lt;/div>
          &lt;script>
            document.querySelector("#pics").onclick = function (ev) {
                if (ev.target.localName.toLowerCase() !== "img") return;
                if (!currentWish) return;
                var xhr = new XMLHttpRequest();
                xhr.open("GET", ev.target.src);
                xhr.responseType = "blob";
                xhr.onload = function () {
                    var file = new File(xhr.response
                                      , ev.target.src.replace(/^.*\//, "")
                                      , { type: xhr.getResponseHeader("Content-Type") }
                    );
                    currentWish.fulfil(currentWish.data.multiple ? [file] : file);
                };
                xhr.send();
            };
          &lt;/script>
        </pre>
      </section>
      <section>
        <h2>Full Duplex Communication</h2>
        <p>
          
        </p>
      </section>
      <section>
        <h2>Embedded Wish</h2>
        <p>
          
        </p>
      </section>
      <section>
        <h2>Installing a Wish</h2>
        <p>
          
        </p>
      </section>
    </section>
    <section id='conformance'></section>
    <section>
      <h2>The <code>Wish</code> interface</h2>
      <p class='issue'>
        Is it really useful to distinguish between fire&amp;forget and return value wish modalities
        through different methods? Maybe instead of <code>once()</code>/<code>then()</code> it
        would be clearer to have it be <code>send()</code>/<code>ask()</code>. That depends on
        whether it makes sense to enable Wishes to behave like Promises in some cases.
      </p>
    </section>
  </body>
</html>
